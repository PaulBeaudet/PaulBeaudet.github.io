---
layout: post
title: "Immediate Versioned Deployment"
author: "Paul Beaudet"
categories: projects
tags: []
image: jitploy_cover_photo.jpg
---

This outlines the goals of Jitploy. A product that addresses issues of deploying software services in a rapid and competitive way without sacrificing stability and sustainability of the service.

### Problem

What happens when a critical fix or feature has been written? How long does it take to get to production? This is the initial problem statement that Jitploy looks to answer. We live in a world where operations and development are starting to like one another. The idea is, with the advent of the hardware pipeline being abstracted away the team can focus on more specific business problems than just the problems of managing software. Thats the hope anyway. In truth the hardware and deployment pipeline is only in progress of being abstracted by third parties and there is a lot of work yet to be done. In the absence of provided solutions developers automate this process away using tool sets and a bewildering collection of automation products. In anticipation of this trending abstraction of hardware, more and more operations and development being construed as the same thing. Given the fact that servers still exist somewhere and magic only exist at Hogwarts, operations automation task are on the onus of the developer or vice versa. Slowed down with process of managing automation and it takes attention away from core business goals. Having the exact opposite affect of the the assumed trend.

### Current Friction

Engineering is apt to integrate automated testing in line, synchronously with production release methodology to prevent regression. Which creates a bottle neck in critical triage situations. Often times rollback is possible, but hot fixes are too complex to consider attempting or might be difficult and or error prone to pull back into version control. Configuration is normally divorced from a service's version control. Typically this is because of configuration sensitivity and different mutations of environmental targets. As a result configuration and environment are managed with centralized orchestration tools geared towards assisting traditionally operations only oriented employees. Who likely only coordinated manual and semi-automatic release task because they were only ever a step in that cycle. An important note about how these tools work is that they typically put all configuration in one basket which is to say in plain text in a private versioned repository. Which defeats the idea of keeping sensitive information out of version control. It is more of a solution to propagating multiple environments. Sometimes sensitive bits are encrypted with a public key that the central build server has the private key to. Normally entails an extra encrypt step per variable in development. A step that consequently hides sensitive information from people the organization should trust. Also, services built with interpreted languages should be able to forgo build servers to speed up development and deployment operations. Managing shared build configuration tools, building integration, and building deployment systems are tangential to likely desired core competencies of most hired developers.

### Immediate Versioned Deployment

Jitploy deploys services based on a push to a source control branch. With little setup time and ability to federate deployments to internal and customer provisioned services. Operations task are abstracted away and exist as service configuration files within the repository. The important detail is that environment and configuration is setup per service and managed with in that service's repository. Environment variables are encrypted with a shared key that is used when setting the service up. Benefit being all aspects of a running service can be versioned in a singular repository and those keys can be disclosed to the end operator or developer per environment. It gives them a complete view of the working service in a central place. Jitploy is actually pretty simple in terms of describing the solution. You push to a branch, that branch can deploy a specific environment or many. This is immediate versioned deployment, makes rolling back as easy as reverting to a previous commit and pushing. Knowing how to use the version control system is knowing how to use Jitploy. In this way hot fixes in mission critical situations are moments away and integration test can still run off of development specific branches in parallel instead of in line. Develop when its time to develop, test when its time to test, deploy when its time to deploy, and fix when its time to fix. The suggestion here is small modular services to increase deployment velocity, but it can be as modular or monolithic as the developer likes.

![jitploy_diagram](/assets/img/jitploy_diagram.jpg)

### How does it work?

 `Note: Currently one can sign up as interested and depending on access situation to the beta product might be available with a subset of the features described above and below`

Jitploy can be setup by registering a github webhook or similar event webhook from the service's master version control repository. This happens through Jitploy's web interface. Pick a plan based on the amount of connections are intended to be allowed. Then give jitploy permission to create a webhook in the repository. Once the hook is created, the Jitploy client can be installed on the target run and development environments. With node.js/npm 'npm install -g jitploy' or deploy the cloud client to deploy within cloud ecosystem of choice. Jitploy's node client just needs a clear tls(port 443) path to connect with its host server that listens to and determines the authenticity of webhook events from source control. Note that node clients are connected through websockets making the connection persistent and able to traverse into local networks. The client on the development machine should be used to encrypt a yml configuration file that holds the environment variables that the service needs to work. 'Jitploy lock .' will generate a default version controlled plain text file that serves as an example template to all environments. Using Jitploy lock for a non-existing environment will generate a template based on the changes that are made in default.yml, 'jitploy lock -e "prod" .'. From here locking will create an encrypted file that can be safely committed to version control. The client (node or cloud) on the deploy target needs to be setup with the desired, repository, environment, and configuration key used to lock that environment, this can be found in the untracked decrypted_env.yml file on the development machine where the key value store of the environment variables was originated. When using node.js and the Jitploy client git clone can be used to establish the initial project and package.json can be used to figure the repository. In root of project, Jitploy -e "prod" -k "your_config_key" -r "repo_address" yourService.js  

### The Moonshot

Goal X. Live in a world where entry level developers sign up for jitploy use a provided provisioning template to write some basic code and deploy their first hello world to the real world

Goal Y. Live in a world where new a new contributer can hit the floor running furthering a projects aspirations.

Goal Z. Live in a world all running services are evolving and keep up to date in an automated way with a modest effort on the part of the maintainer

<script>(function(t,e,s,n){var o,a,c;t.SMCX=t.SMCX||[],e.getElementById(n)||(o=e.getElementsByTagName(s),a=o[o.length-1],c=e.createElement(s),c.type="text/javascript",c.async=!0,c.id=n,c.src=["https:"===location.protocol?"https://":"http://","widget.surveymonkey.com/collect/website/js/tRaiETqnLgj758hTBazgd4RfAc4LbLy4SQyG5gfT_2BDh253ZdoU8Ceik1dkLaAwV4.js"].join(""),a.parentNode.insertBefore(c,a))})(window,document,"script","smcx-sdk");</script>
